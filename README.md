# 信手相连
---
这里是lwy信手相连活动的仓库:smile:

video文件夹存储上课录屏的百度云盘(因为github单个文件不能太大)

如果可以的话之后大家可以把资料啥的都聚一聚

## course1
**wiki资源**

oi-wiki: https://oi-wiki.org/

cs-wiki: https://csdiy.wiki/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/

**刷题网站**

洛谷: https://www.luogu.com.cn/

codeforces: https://www.luogu.com.cn/

vjudge: https://vjudge.net/

力扣leetcode: https://leetcode-cn.com/

牛客网: https://www.nowcoder.com/

**语言基础**

菜鸟教程: https://www.runoob.com/

**算法、数据结构可视化**

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

## course2
### debug
相信大家应该都配置好了debug环境。上次断点跳转的原因是我打断点的地方是声明语句，而声明语句除非是你写错了报语法错误；否则声明语句不可能在运行的时候出问题，因此调试程序不允许也不用你在那打断点，而是会自动跳到可以断点的位置。
### 数组
最开始是用来存储的(比如让你们顺序读入一堆数，然后逆序输出)
数组的妙用：
https://blog.csdn.net/lanchunhui/article/details/51518131
比如数组可以做计数器
以存代算的记录思想
### 枚举
**循环不等于枚举**

同一段逻辑可以由不同的代码写出来，刷题少时可能感觉自己的代码麻烦，这个时候就可以去和别人交流从而获得更好的思路。

枚举就是列举(for)解空间中所有的结果，并挨个进行尝试(for内部)，最终筛选(if-else)出符合条件的我们想要的结果。所以对于一些简单的题，我们只要关注最后输出是什么，即我们想要什么，就可以知道应该枚举什么，但是对于有些题，枚举可能是中间过程，从枚举结果到最终输出还有一段距离。

我的建议：枚举前加注释说明这段枚举是在干什么，枚举中的ifelse注释分别是哪些条件。因为你很有可能写着写着忘了内部循环该怎么写。

先分析得出总体思路 自顶向下或自底向上，建议思路从上到下(想好大概需要哪些东西，哪些需要优化，多个部分如何链接)、写的时候从下到上(一个一个搭积木搭建起来，搭一点测一点，多printf，甚至你可以设一个#define PRINT和#ifdef)
其中包括读入思路
然后写读入，并**测试**读入是否正确
不会的函数就去查，记得多了就好了，比如我就不记得求字符串长度的strlen了
我也出问题，比如""和''不分，仔细查看报错原因，不懂就查。
然后适当改写程序结构，使其美观，减少运算量
最后加特判，比如是不是首位为X
long long
一些经典的架构
```c++
while(1)
{
    if(...)
    {
        break;
    }
}
```
```c++
int flag=0;
for()
{
    if(...)
    {
        flag=1;
    }
}
if(flag==1)
{
    output=...
}
else
{
    output=...
}
```

### 例题
难度递增顺序：
182
643
134


## course3
### review
原来大家还没有讲到函数，上次那个strlen和atoi其实可以替换成自己的代码比如：
```cpp
// strlen
int len = 0;//已经到达的长度
for(len=0;s[len]!='\0';len++)
{
    //当取到的值是\0说明字符串结束了
}
//这里的len就是字符串长度了
```

### 结构体
结构体有什么用？

结构体能够把一个东西的**多个属性放在一起**，形成一个**整体**，相当于自己定义了一个**新的数据类型**。(比如一个学生，有学号、成绩之类的)

所以当你需要很多的东西时，怎么办？开个结构体数组，不就是一堆学生了。因为数组最开始的定义就是相同数据有很多个。

还有什么呢，还有结构体里面嵌结构体，就是信息的进一步聚合。
```cpp
struct Point
{
    int x,y;//横纵坐标
};
struct Triangle
{
    Point vertexs[3];//三角形的三个顶点
}
```

### 排序
排序是什么？

排序是按照**我们定义的比较规则**，将一些无关的数据挨个摆着。(大佬看这里:现在只讲基于比较的排序，上限O(nlogn)，还有不基于比较的，你们自己去查)

比如一般意义的<，这个规则说明了1比2小，2比3小。

再比如我现在有三个玩具：🐢、🚒、🎂，我现在就是要求消防车最大，乌龟次之，蛋糕最小。那么给你一串这样的玩具，你会把它排号，这里的**比较规则**就是我们定义的了。

**排序算法**则是大家已经发现的，能够完成这一任务的方法，当然大家的水平不一样，所以有的快有的慢，甚至有的人排不对。比如上面这个，最简单的思路就是我一个一个去看，找到消防车就往前面放，找到就放，没有了再找乌龟。(当然这个很慢很慢)

先掌握冒泡和选择排序，当然所有排序在目的上都是等价的，只是时间的问题。之后会教快排，插个眼：一定一定一定要自己能直接敲出快排的代码，不要问为什么。

### 结构体+排序
结构体给了你高度的**数据自由**，排序给了你决定**比较规则的自由**，所以能结合的很好。(也能出很多题)

Notes:
对结构体排序时，往往只有一部分数据是作为比较使用的，其他一部分是牵连、顺带着走的，例如没办法题目要求输出的玩意

### 代码结构(当然写之前肯定得有解题思路)
1. 全体初始化
2. 读取**提示信息**(提示你接下来读多少个的数，这个数往往只会用在for循环的循环次数控制里面，用完就丢了)和**数据信息**(有实际意义的，需要保留下来的数据)
3. 将读取到的原有数据进行一定的处理，产生方便后续使用的其他信息
4. 排序(关键在于定义比较规则)
5. 输出

### 例题
90 486


## course4 
### 读入问题
1. 有若干组字符串，最后以"END"结尾，表示读入结束(数字的话一般是0,-1等)
```cpp
char s[20];
while(1)
{
    //先读
    scanf("%s",s);
    //然后比较是不是END，如果是就退出
    if(strcmp(s,"END")==0)break;
    //否则就做该做的
    ...
}
```
2. 接下来一行是一个数字n，表示后面有n个字符串
```cpp
//其实就是上节课说的提示信息
int n;
char s[20];
scanf("%d",&n);
for(int i=0;i<n;i++)
{
    scanf("%s",s);
    ...
}
```
3. (啥也没说,不知道读多少行，这种情况一般是在文件读入的时候，因为终端读入会等待你输入，而文件其实隐藏了末尾的结束标记)
```cpp
// 因为scanf的返回值是读入成功的个数
char s[20];
while(scanf("%s",s)!=0)
{
    ...
}
```

### 分类讨论
当有时候题目太复杂或者情况很多时，不妨假设一些值，做出来之后再把这些值写成一个变的值。

### 结构体作为返回值
因为return 只能返回一个值，当你想返回多个值时，可以把返回值单独当作一个结构体
```cpp
struct ReturnValue
{
    int pos;//position
    int value;//value
};
```

### 最大回文子串
给定一个字符串s，求s的最大回文子串，例如abbcba，则输出bb
	#a#b#b#c#b#a#b#a
串!=序列

空隙插入特殊字符#
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int dp[N][N];
int main()
{
    string str;
    getline(cin,str);
    int res=0;
    for(int i=0;i<str.length();i++)
    {
        int l=i-1,r=i+1;//判断奇数长度回文串
        while(l>=0&&r<str.length()&&str[l]==str[r]) l--,r++;
        res=max(res,r-l-1);
        l=i,r=i+1;//判断偶数长度回文串
        while(l>=0&&r<str.length()&&str[l]==str[r]) l--,r++;
        res=max(res,r-l-1);
    }
    cout<<res<<endl;
    return 0;
}
```
拓展：DP，二分+hash，Manacher算法

### 筛法求质数


```cpp
// 朴素筛求质数，时间复杂度：O(n*log(n))
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = i + i; j <= n; j += i) st[j] = true;
    }
}
```
拓展：挨拉托色尼筛，欧拉筛

### 数位分离和进制转换
```cpp
#include <stdio.h>

int main()
{

	int a, x;

	/* 数位分离 */
	// 主要利用整除和取余两种运算来获取某一位上的数

	/* 获取个位 */
	x = a % 10;
	/* 获取十位 */
	x = (a / 10) % 10; // 对十整除之后，十位就变到了原来个位的位置上，通过这样两种运算就可以获得任意数位的数
	/* 获取第k位（从个位数起） */
	x = a;
	for (int i = 1; i <= k - 1; i++)
		x /= 10; // 除去10^(k-1)，多次查询的时候可以把它预先存到数组里，之后查表即可
	x %= 10;
	/* 获取第 p-q 位之间的数 */
	int pow_10[];						 // 存放10的幂
	// 123456
	// q   p
	x = (a / pow_10[p - 1]) % pow_10[q]; // 先把p位之后的数抹掉，再把q位之前的数抹掉

	// 同理，对于p进制的数也一样处理，只需要把10换成p就可以了，即
	x = a % p;
	/* 特别地，由于在系统中数字是通过二进制存储的，我们可以利用“位运算”的方法方便的取出二进制中的某一位，在这里不详细展开。 */
	x = (a & (1 << k - 1)); // 获取二进制下a的第k位
	// 111001101010
	// 100101010010
	/* 进制转换 */
	// 用10进制作为中介可以完成任意m到n进制的转换

	int a_n, a_10;
	/* n进制转化为10进制 */
	int x = 1; // 表示现在末尾的1代表的是n的多少次方
	while (a_n > 0)
	{
		a_10 += (a_n % 10) * x; // 取出当前数的个位，乘上它实际代表的大小
		a_n /= 10;				// 继续考虑下一位
		x *= n;					// 更新为现在的末尾代表的n的次方
	}							// 这个数的最高位转化完了之后，变成了0，转化完成

	/* 10进制转化为m进制 */
	// 由于int类型默认十进制，因此我们用数组来存m进制下的每一位
	int a[];
	for (int i = 0; a_10 > 0; i++)
	{
		a[i] = a_10 % m; // 取出当前最末位
		a_10 /= m;		 // 删掉当前位
	}

	return 0;
}
```
关键点就在于"%"是提取后面几位，"/"就是去除最后几位。易错点就是**是否对原数做了修改**。

### 字符串复习练习题
可以找洛谷的字符串专题，比如

https://www.luogu.com.cn/problem/P1957 

https://www.luogu.com.cn/problem/P1125

