# 信手相连
---
这里是lwy信手相连活动的仓库:smile:

video文件夹存储上课录屏的百度云盘(因为github单个文件不能太大)

如果可以的话之后大家可以把资料啥的都聚一聚

## course1
**wiki资源**

oi-wiki: https://oi-wiki.org/

cs-wiki: https://csdiy.wiki/CS%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/

**刷题网站**

洛谷: https://www.luogu.com.cn/

codeforces: https://www.luogu.com.cn/

vjudge: https://vjudge.net/

力扣leetcode: https://leetcode-cn.com/

牛客网: https://www.nowcoder.com/

**语言基础**

菜鸟教程: https://www.runoob.com/

**算法、数据结构可视化**

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

## course2
### debug
相信大家应该都配置好了debug环境。上次断点跳转的原因是我打断点的地方是声明语句，而声明语句除非是你写错了报语法错误；否则声明语句不可能在运行的时候出问题，因此调试程序不允许也不用你在那打断点，而是会自动跳到可以断点的位置。
### 数组
最开始是用来存储的(比如让你们顺序读入一堆数，然后逆序输出)
数组的妙用：
https://blog.csdn.net/lanchunhui/article/details/51518131
比如数组可以做计数器
以存代算的记录思想
### 枚举
**循环不等于枚举**

同一段逻辑可以由不同的代码写出来，刷题少时可能感觉自己的代码麻烦，这个时候就可以去和别人交流从而获得更好的思路。

枚举就是列举(for)解空间中所有的结果，并挨个进行尝试(for内部)，最终筛选(if-else)出符合条件的我们想要的结果。所以对于一些简单的题，我们只要关注最后输出是什么，即我们想要什么，就可以知道应该枚举什么，但是对于有些题，枚举可能是中间过程，从枚举结果到最终输出还有一段距离。

我的建议：枚举前加注释说明这段枚举是在干什么，枚举中的ifelse注释分别是哪些条件。因为你很有可能写着写着忘了内部循环该怎么写。

先分析得出总体思路 自顶向下或自底向上，建议思路从上到下(想好大概需要哪些东西，哪些需要优化，多个部分如何链接)、写的时候从下到上(一个一个搭积木搭建起来，搭一点测一点，多printf，甚至你可以设一个#define PRINT和#ifdef)
其中包括读入思路
然后写读入，并**测试**读入是否正确
不会的函数就去查，记得多了就好了，比如我就不记得求字符串长度的strlen了
我也出问题，比如""和''不分，仔细查看报错原因，不懂就查。
然后适当改写程序结构，使其美观，减少运算量
最后加特判，比如是不是首位为X
long long
一些经典的架构
```c++
while(1)
{
    if(...)
    {
        break;
    }
}
```
```c++
int flag=0;
for()
{
    if(...)
    {
        flag=1;
    }
}
if(flag==1)
{
    output=...
}
else
{
    output=...
}
```

### 例题
难度递增顺序：
182
643
134


## course3
### review
原来大家还没有讲到函数，上次那个strlen和atoi其实可以替换成自己的代码比如：
```cpp
// strlen
int len = 0;//已经到达的长度
for(len=0;s[len]!='\0';len++)
{
    //当取到的值是\0说明字符串结束了
}
//这里的len就是字符串长度了
```

### 结构体
结构体有什么用？

结构体能够把一个东西的**多个属性放在一起**，形成一个**整体**，相当于自己定义了一个**新的数据类型**。(比如一个学生，有学号、成绩之类的)

所以当你需要很多的东西时，怎么办？开个结构体数组，不就是一堆学生了。因为数组最开始的定义就是相同数据有很多个。

还有什么呢，还有结构体里面嵌结构体，就是信息的进一步聚合。
```cpp
struct Point
{
    int x,y;//横纵坐标
};
struct Triangle
{
    Point vertexs[3];//三角形的三个顶点
}
```

### 排序
排序是什么？

排序是按照**我们定义的比较规则**，将一些无关的数据挨个摆着。(大佬看这里:现在只讲基于比较的排序，上限O(nlogn)，还有不基于比较的，你们自己去查)

比如一般意义的<，这个规则说明了1比2小，2比3小。

再比如我现在有三个玩具：🐢、🚒、🎂，我现在就是要求消防车最大，乌龟次之，蛋糕最小。那么给你一串这样的玩具，你会把它排号，这里的**比较规则**就是我们定义的了。

**排序算法**则是大家已经发现的，能够完成这一任务的方法，当然大家的水平不一样，所以有的快有的慢，甚至有的人排不对。比如上面这个，最简单的思路就是我一个一个去看，找到消防车就往前面放，找到就放，没有了再找乌龟。(当然这个很慢很慢)

先掌握冒泡和选择排序，当然所有排序在目的上都是等价的，只是时间的问题。之后会教快排，插个眼：一定一定一定要自己能直接敲出快排的代码，不要问为什么。

### 结构体+排序
结构体给了你高度的**数据自由**，排序给了你决定**比较规则的自由**，所以能结合的很好。(也能出很多题)

Notes:
对结构体排序时，往往只有一部分数据是作为比较使用的，其他一部分是牵连、顺带着走的，例如没办法题目要求输出的玩意

### 代码结构(当然写之前肯定得有解题思路)
1. 全体初始化
2. 读取**提示信息**(提示你接下来读多少个的数，这个数往往只会用在for循环的循环次数控制里面，用完就丢了)和**数据信息**(有实际意义的，需要保留下来的数据)
3. 将读取到的原有数据进行一定的处理，产生方便后续使用的其他信息
4. 排序(关键在于定义比较规则)
5. 输出

### 例题
90 486
